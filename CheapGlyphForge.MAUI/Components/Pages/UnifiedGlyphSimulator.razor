@page "/simulator"
@using CheapGlyphForge.Core.Interfaces
@using CheapGlyphForge.Core.Models
@using CheapGlyphForge.Core.Helpers
@using MudBlazor
@using System.Diagnostics
@inject IGlyphInterfaceService InterfaceService
@inject IGlyphMatrixService MatrixService
@inject ISnackbar Snackbar

<PageTitle>Unified Glyph Simulator</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="pa-6">

    <!-- Header Section -->
    <MudPaper Class="pa-4 mb-4" Elevation="2">
        <MudGrid AlignItems="Center">
            <MudItem xs="12" md="8">
                <MudText Typo="Typo.h4" Class="mb-2">🔆 Unified Glyph Simulator</MudText>
                <MudText Typo="Typo.body1" Color="Color.Secondary">
                    Simulate Nothing Phone Glyph Interface (5 channels) and Matrix (25×25 LED grid) without hardware conflicts
                </MudText>
            </MudItem>
            <MudItem xs="12" md="4" Class="text-right">
                <MudChip T="string" Icon="@GetConnectionIcon()" Color="@GetConnectionColor()" Label="true">
                    @GetConnectionStatus()
                </MudChip>
            </MudItem>
        </MudGrid>
    </MudPaper>

    <!-- Mode Selection -->
    <MudPaper Class="pa-4 mb-4" Elevation="1">
        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined" Class="mb-3">
            <MudButton StartIcon="Icons.Material.Filled.Lightbulb"
                       Variant="@(_simulationMode == SimulationMode.Interface ? Variant.Filled : Variant.Outlined)"
                       OnClick="() => SetSimulationMode(SimulationMode.Interface)">
                Interface Mode
            </MudButton>
            <MudButton StartIcon="Icons.Material.Filled.GridOn"
                       Variant="@(_simulationMode == SimulationMode.Matrix ? Variant.Filled : Variant.Outlined)"
                       OnClick="() => SetSimulationMode(SimulationMode.Matrix)">
                Matrix Mode
            </MudButton>
            <MudButton StartIcon="Icons.Material.Filled.ViewModule"
                       Variant="@(_simulationMode == SimulationMode.Unified ? Variant.Filled : Variant.Outlined)"
                       OnClick="() => SetSimulationMode(SimulationMode.Unified)">
                Unified View
            </MudButton>
        </MudButtonGroup>

        <MudSelect T="GlyphDeviceType" Label="Device Type" @bind-Value="_selectedDevice" Variant="Variant.Outlined" Class="mb-2">
            @foreach (var device in Enum.GetValues<GlyphDeviceType>())
            {
                <MudSelectItem T="GlyphDeviceType" Value="device">@GetDeviceDisplayName(device)</MudSelectItem>
            }
        </MudSelect>
    </MudPaper>

    <MudGrid>
        <!-- Phone Visualization -->
        <MudItem xs="12" lg="8">
            <MudPaper Class="pa-4" Elevation="2">
                <MudText Typo="Typo.h6" Class="mb-4">Nothing Phone Simulation</MudText>

                <!-- Phone Outline Container -->
                <div style="position: relative; width: 100%; max-width: 400px; margin: 0 auto; aspect-ratio: 0.47;">

                    <!-- Phone Background -->
                    <div style="position: absolute; width: 100%; height: 100%; background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); border-radius: 24px; border: 2px solid #404040;"></div>

                    <!-- Interface Channels (if enabled) -->
                    @if (_simulationMode == SimulationMode.Interface || _simulationMode == SimulationMode.Unified)
                    {
                        @foreach (var channel in GetVisibleChannels())
                        {
                            string style = $@"width: 100%; height: 100%; background-color: {GetChannelColor(channel)} border-radius: 8px; cursor: pointer; transition: all 0.3s ease;";
                            <div style="@GetChannelStyle(channel)" @onclick="() => ToggleChannel(channel)">
                                <MudPaper Style=@style Elevation="@(GetChannelIntensity(channel) > 0 ? 4 : 1)"></MudPaper>
                            </div>
                        }
                    }

                    <!-- Matrix Overlay (if enabled) -->
                    @if (_simulationMode == SimulationMode.Matrix || _simulationMode == SimulationMode.Unified)
                    {
                        <!-- Matrix LED Grid Overlay with BOUNDS CHECKING -->
                        <div style="@MatrixOverlayStyle">
                            @for (int row = 0; row < IGlyphMatrixService.MatrixHeight; row++)
                            {
                                <div style="display: flex; gap: 1px;">
                                    @for (int col = 0; col < IGlyphMatrixService.MatrixWidth; col++)
                                    {
                                        var pixelIndex = row * IGlyphMatrixService.MatrixWidth + col;

                                        // ✅ CRITICAL: Add bounds checking
                                        @if (pixelIndex >= 0 && pixelIndex < _matrixPixels.Length && _matrixPixels[pixelIndex] != null)
                                        {
                                            var intensity = _matrixPixels[pixelIndex].Intensity;
                                            var pixelStyle = GetMatrixPixelStyle(intensity);

                                            <div style="@pixelStyle" @onclick="() => SafeToggleMatrixPixel(col, row)"></div>
                                        }
                                        else
                                        {
                                            <!-- Fallback for invalid pixels -->
                                            <div style="width: 8px; height: 8px; background-color: red; border: 1px solid white;"></div>
                                        }
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
            </MudPaper>
        </MudItem>

        <!-- Control Panel -->
        <MudItem xs="12" lg="4">
            <MudPaper Class="pa-4" Elevation="2">
                <MudText Typo="Typo.h6" Class="mb-4">Controls</MudText>

                <!-- Interface Controls -->
                @if (_simulationMode == SimulationMode.Interface || _simulationMode == SimulationMode.Unified)
                {
                    <MudExpansionPanels Class="mb-4">
                        <MudExpansionPanel IsExpanded="true">
                            <TitleContent>
                                <div style="display: flex; align-items: center;">
                                    <MudIcon Icon="Icons.Material.Filled.Lightbulb" Class="mr-3" />
                                    <MudText>Interface Channels</MudText>
                                </div>
                            </TitleContent>
                            <ChildContent>
                                @foreach (var channel in GetVisibleChannels())
                                {
                                    <MudGrid AlignItems="Center" Class="mb-2">
                                        <MudItem xs="3">
                                            <MudButton Variant="Variant.Outlined"
                                                       Color="Color.Primary"
                                                       Size="Size.Small"
                                                       OnClick="() => ToggleChannel(channel)">
                                                @channel
                                            </MudButton>
                                        </MudItem>
                                        <MudItem xs="6">
                                            <MudSlider T="int"
                                                       Min="0"
                                                       Max="255"
                                                       Step="1"
                                                       Value="@GetChannelIntensity(channel)"
                                                       ValueChanged="(int value) => SetChannelIntensity(channel, value)"
                                                       Class="mx-2" />
                                        </MudItem>
                                        <MudItem xs="3">
                                            <MudText Typo="Typo.caption">@GetChannelIntensity(channel)</MudText>
                                        </MudItem>
                                    </MudGrid>
                                }

                                <MudDivider Class="my-3" />

                                <MudButtonGroup Variant="Variant.Outlined" Size="Size.Small" Class="mb-2">
                                    <MudButton OnClick="AnimateAllChannels" StartIcon="Icons.Material.Filled.AutoAwesome">
                                        Animate All
                                    </MudButton>
                                    <MudButton OnClick="TurnOffAllChannels" StartIcon="Icons.Material.Filled.PowerOff">
                                        Turn Off
                                    </MudButton>
                                    <MudButton Color="Color.Info" StartIcon="Icons.Material.Filled.Refresh"
                                               OnClick="RefreshMatrixDisplay" Size="Size.Small">
                                        Refresh Display
                                    </MudButton>

                                    <MudButton Color="Color.Secondary" StartIcon="Icons.Material.Filled.BugReport"
                                               OnClick="DumpMatrixState" Size="Size.Small">
                                        Debug Matrix
                                    </MudButton>
                                </MudButtonGroup>
                            </ChildContent>
                        </MudExpansionPanel>
                    </MudExpansionPanels>
                }

                <!-- Matrix Controls -->
                @if (_simulationMode == SimulationMode.Matrix || _simulationMode == SimulationMode.Unified)
                {
                    <MudExpansionPanels Class="mb-4">
                        <MudExpansionPanel IsExpanded="true">
                            <TitleContent>
                                <div style="display: flex; align-items: center;">
                                    <MudIcon Icon="Icons.Material.Filled.GridOn" Class="mr-3" />
                                    <MudText>Matrix Controls</MudText>
                                </div>
                            </TitleContent>
                            <ChildContent>
                                <MudGrid Class="mb-3">
                                    <MudItem xs="6">
                                        <MudNumericField T="int"
                                                         Label="X Position"
                                                         @bind-Value="_matrixX"
                                                         Min="0"
                                                         Max="24"
                                                         Variant="Variant.Outlined" />
                                    </MudItem>
                                    <MudItem xs="6">
                                        <MudNumericField T="int"
                                                         Label="Y Position"
                                                         @bind-Value="_matrixY"
                                                         Min="0"
                                                         Max="24"
                                                         Variant="Variant.Outlined" />
                                    </MudItem>
                                </MudGrid>

                                <MudSlider T="int"
                                           Label="Intensity"
                                           Min="0"
                                           Max="255"
                                           Step="1"
                                           @bind-Value="_matrixIntensity"
                                           Class="mb-3" />

                                <MudButtonGroup Variant="Variant.Outlined" Size="Size.Small" Class="mb-3">
                                    <MudButton OnClick="SetPixelAtPosition" StartIcon="Icons.Material.Filled.Add">
                                        Set Pixel
                                    </MudButton>
                                    <MudButton OnClick="ClearMatrixPixels" StartIcon="Icons.Material.Filled.Clear">
                                        Clear All
                                    </MudButton>
                                    <MudButton Color="Color.Error" StartIcon="Icons.Material.Filled.BugReport"
                                               OnClick="DiagnoseArrayIssues" Size="Size.Small">
                                        🔍 Diagnose Array
                                    </MudButton>

                                    <MudButton Color="Color.Warning" StartIcon="Icons.Material.Filled.Healing"
                                               OnClick="ForceReinitializeArrays" Size="Size.Small">
                                        🚑 Force Reinit
                                    </MudButton>

                                </MudButtonGroup>
                                <MudText Typo="Typo.caption" Class="mt-2">@_debugArrayInfo</MudText>
                                <MudText Typo="Typo.subtitle2" Class="mb-2">Quick Patterns:</MudText>
                                <MudButtonGroup Variant="Variant.Text" Size="Size.Small">
                                    <MudButton OnClick="() => DrawPattern(MatrixPattern.Cross)" StartIcon="Icons.Material.Filled.Add">
                                        Cross
                                    </MudButton>
                                    <MudButton OnClick="() => DrawPattern(MatrixPattern.Circle)" StartIcon="Icons.Material.Filled.RadioButtonUnchecked">
                                        Circle
                                    </MudButton>
                                    <MudButton OnClick="() => DrawPattern(MatrixPattern.Square)" StartIcon="Icons.Material.Filled.CropSquare">
                                        Square
                                    </MudButton>
                                </MudButtonGroup>
                            </ChildContent>
                        </MudExpansionPanel>
                    </MudExpansionPanels>
                }

                <!-- Status Information -->
                <MudCard Class="mt-4">
                    <MudCardContent>
                        <MudText Typo="Typo.subtitle2" Class="mb-2">Status</MudText>
                        <MudText Typo="Typo.caption" Color="Color.Secondary">
                            Active Channels: @_activeChannels.Count<br />
                            Active Pixels: @_matrixPixels.Count(p => p.Intensity > 0)<br />
                            Last Update: @_lastUpdate.ToString("HH:mm:ss")
                        </MudText>
                    </MudCardContent>
                </MudCard>
            </MudPaper>
        </MudItem>
    </MudGrid>
</MudContainer>

@code {
    // Constants
    private const string PhoneOutlineColor = "#2d2d2d";
    private const string ActiveGlyphColor = "#00ff88";
    private const string InactiveGlyphColor = "#404040";

    private int _debugPixelCount = 0;
    private string _debugArrayInfo = "";

    // State
    private SimulationMode _simulationMode = SimulationMode.Unified;
    private GlyphDeviceType _selectedDevice = GlyphDeviceType.Phone3;
    private readonly Dictionary<string, int> _channelIntensities = [];
    private readonly HashSet<string> _activeChannels = [];
    private readonly GlyphPixel[] _matrixPixels = new GlyphPixel[IGlyphMatrixService.TotalPixels];
    private int _matrixX = 12;
    private int _matrixY = 12;
    private int _matrixIntensity = 255;
    private DateTime _lastUpdate = DateTime.Now;

    // Style properties
    private string MatrixOverlayStyle =>
        "position: absolute; top: 20%; left: 20%; width: 60%; height: 60%; display: flex; flex-direction: column; gap: 1px; opacity: 0.9;";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            Debug.WriteLine("=== KOWALSKI INITIALIZATION SEQUENCE ===");

            // ✅ Step 1: Initialize data structures FIRST
            InitializeChannelMappings();
            InitializeMatrixPixels();
            Debug.WriteLine("✅ Data structures initialized");

            // ✅ Step 2: Initialize services with error handling
            await InitializeServicesAsync();
            Debug.WriteLine("✅ Services initialized");

            // ✅ Step 3: Subscribe to events LAST
            await SubscribeToServiceEvents();
            Debug.WriteLine("✅ Event subscriptions complete");

            Debug.WriteLine("=== INITIALIZATION COMPLETE ===");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"🚨 CRITICAL INITIALIZATION FAILURE: {ex.Message}");
            Debug.WriteLine($"Stack trace: {ex.StackTrace}");

            // Try to recover with minimal initialization
            try
            {
                InitializeChannelMappings();
                InitializeMatrixPixels();
                Snackbar.Add("Initialization failed - running in recovery mode", Severity.Error);
            }
            catch (Exception recoveryEx)
            {
                Debug.WriteLine($"🚨 RECOVERY FAILED: {recoveryEx.Message}");
                Snackbar.Add("Critical initialization failure", Severity.Error);
            }
        }
    }

    private async Task DiagnoseArrayIssues()
    {
        try
        {
            Debug.WriteLine("=== 🔍 KOWALSKI ARRAY DIAGNOSTICS ===");

            Debug.WriteLine($"_matrixPixels.Length: {_matrixPixels.Length}");
            Debug.WriteLine($"Expected Length: 625 (25x25)");
            Debug.WriteLine($"IGlyphMatrixService.TotalPixels: {IGlyphMatrixService.TotalPixels}");

            var nullCount = _matrixPixels.Count(p => p == null);
            var nonNullCount = _matrixPixels.Length - nullCount;

            Debug.WriteLine($"Null pixels: {nullCount}");
            Debug.WriteLine($"Non-null pixels: {nonNullCount}");

            _debugArrayInfo = $"Array: {_matrixPixels.Length}/625, Null: {nullCount}, Valid: {nonNullCount}";

            // Test a few specific indices
            var testIndices = new[] { 0, 100, 312, 624 };
            foreach (var index in testIndices)
            {
                if (index < _matrixPixels.Length)
                {
                    var pixel = _matrixPixels[index];
                    Debug.WriteLine($"Index {index}: {(pixel == null ? "NULL" : $"({pixel.X},{pixel.Y})={pixel.Intensity}")}");
                }
                else
                {
                    Debug.WriteLine($"Index {index}: OUT OF BOUNDS");
                }
            }

            Debug.WriteLine("=== END DIAGNOSTICS ===");
            StateHasChanged();
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"🚨 Diagnostics failed: {ex.Message}");
            _debugArrayInfo = $"Diagnostics failed: {ex.Message}";
        }
    }

    private async Task ForceReinitializeArrays()
    {
        try
        {
            Debug.WriteLine("🚑 FORCE REINITIALIZING ARRAYS...");

            // Clear and reinitialize
            Array.Clear(_matrixPixels, 0, _matrixPixels.Length);

            for (int i = 0; i < _matrixPixels.Length; i++)
            {
                var x = i % 25;
                var y = i / 25;
                _matrixPixels[i] = new GlyphPixel(x, y, 0);
            }

            // Clear and reinitialize channel mappings
            _channelIntensities.Clear();
            _activeChannels.Clear();
            InitializeChannelMappings();

            Debug.WriteLine("✅ Force reinitialization complete");
            _debugArrayInfo = "Force reinitialization completed successfully";

            Snackbar.Add("Arrays reinitialized successfully", Severity.Success);
            StateHasChanged();
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"🚨 Force reinit failed: {ex.Message}");
            _debugArrayInfo = $"Force reinit failed: {ex.Message}";
            Snackbar.Add("Reinitialization failed", Severity.Error);
        }
    }

    private void InitializeChannelMappings()
    {
        var channels = GetVisibleChannels();
        foreach (var channel in channels)
        {
            _channelIntensities[channel] = 0;
        }
    }

    private async Task InitializeServicesAsync()
    {
        try
        {
            Debug.WriteLine("UnifiedGlyphSimulator: Initializing services...");

            // Initialize both services with timeout
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));

            var interfaceTask = InterfaceService.InitializeAsync();
            var matrixTask = MatrixService.InitializeAsync();

            var results = await Task.WhenAll(interfaceTask, matrixTask).WaitAsync(cts.Token);

            var interfaceResult = await interfaceTask;
            var matrixResult = await matrixTask;

            Debug.WriteLine($"Interface service initialized: {interfaceResult}");
            Debug.WriteLine($"Matrix service initialized: {matrixResult}");

            // Register device if at least one service initialized
            if (interfaceResult || matrixResult)
            {
                if (interfaceResult)
                {
                    await InterfaceService.RegisterDeviceAsync(_selectedDevice);
                }
                if (matrixResult)
                {
                    await MatrixService.RegisterDeviceAsync(_selectedDevice);
                }
                Debug.WriteLine($"Services registered for device: {_selectedDevice}");
            }
            else
            {
                Debug.WriteLine("⚠️ Both services failed to initialize");
                Snackbar.Add("Service initialization failed", Severity.Warning);
            }

            StateHasChanged();
        }
        catch (TimeoutException)
        {
            Debug.WriteLine("⚠️ Service initialization timed out");
            Snackbar.Add("Service initialization timed out", Severity.Warning);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"🚨 Service initialization failed: {ex.Message}");
            Snackbar.Add($"Service initialization failed: {ex.Message}", Severity.Error);
        }
    }

    private void InitializeMatrixPixels()
    {
        try
        {
            const int expectedSize = 625; // 25 * 25
            Debug.WriteLine($"Initializing matrix pixels array - Expected size: {expectedSize}");

            // Ensure array is correct size
            if (_matrixPixels.Length != expectedSize)
            {
                Debug.WriteLine($"⚠️ Matrix pixels array wrong size: {_matrixPixels.Length}, expected {expectedSize}");
                // This might require recreating the array at class level
            }

            for (int i = 0; i < _matrixPixels.Length && i < expectedSize; i++)
            {
                var x = i % 25; // Use constants
                var y = i / 25;
                _matrixPixels[i] = new GlyphPixel(x, y, 0);
            }

            Debug.WriteLine($"✅ Matrix pixels initialized successfully - Array size: {_matrixPixels.Length}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"🚨 Matrix pixel initialization failed: {ex.Message}");
            throw; // Re-throw to be caught by parent
        }
    }

    private async Task SubscribeToServiceEvents()
    {
        try
        {
            // ✅ Subscribe to service events with null checks
            if (InterfaceService != null)
            {
                InterfaceService.ConnectionChanged += OnInterfaceConnectionChanged;
                Debug.WriteLine("✅ Interface service events subscribed");
            }

            if (MatrixService != null)
            {
                MatrixService.ConnectionChanged += OnMatrixConnectionChanged;
                MatrixService.FrameUpdated += OnMatrixFrameUpdated;
                Debug.WriteLine("✅ Matrix service events subscribed");
            }

            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"⚠️ Event subscription failed: {ex.Message}");
        }
    }

    private void OnInterfaceConnectionChanged(object? sender, bool isConnected)
    {
        Debug.WriteLine($"Interface connection changed: {isConnected}");
        InvokeAsync(StateHasChanged);
    }

    private void OnMatrixConnectionChanged(object? sender, bool isConnected)
    {
        Debug.WriteLine($"Matrix connection changed: {isConnected}");
        InvokeAsync(StateHasChanged);
    }

    // Mode Management
    private async Task SetSimulationMode(SimulationMode mode)
    {
        _simulationMode = mode;
        Debug.WriteLine($"Simulation mode changed to: {mode}");

        if (mode == SimulationMode.Interface)
        {
            await ClearMatrixPixels();
        }
        else if (mode == SimulationMode.Matrix)
        {
            await TurnOffAllChannels();
        }

        StateHasChanged();
    }

    // Device Management
    private string GetDeviceDisplayName(GlyphDeviceType device) => device switch
    {
        GlyphDeviceType.Phone1 => "Nothing Phone (1)",
        GlyphDeviceType.Phone2 => "Nothing Phone (2)",
        GlyphDeviceType.Phone2a => "Nothing Phone (2a)",
        GlyphDeviceType.Phone2aPlus => "Nothing Phone (2a) Plus",
        GlyphDeviceType.Phone3 => "Nothing Phone (3)",
        _ => device.ToString()
    };

    private List<string> GetVisibleChannels() => _selectedDevice switch
    {
        GlyphDeviceType.Phone1 => ["A", "B", "C", "D"],
        GlyphDeviceType.Phone2 => ["A", "B", "C", "D", "E"],
        GlyphDeviceType.Phone2a or GlyphDeviceType.Phone2aPlus => ["A", "B", "C"],
        GlyphDeviceType.Phone3 => ["A", "B", "C"],
        _ => ["A", "B", "C"]
    };

    // Channel Management
    private async Task ToggleChannel(string channel)
    {
        if (!InterfaceService.IsConnected)
        {
            Debug.WriteLine("Interface service not connected, attempting to initialize...");
            await InterfaceService.InitializeAsync();
            await InterfaceService.RegisterDeviceAsync(_selectedDevice);
        }

        if (InterfaceService.IsConnected && !InterfaceService.IsSessionOpen)
        {
            await InterfaceService.OpenSessionAsync();
        }

        if (_activeChannels.Contains(channel))
        {
            await SetChannelIntensity(channel, 0);
        }
        else
        {
            await SetChannelIntensity(channel, 255);
        }
    }

    private int GetChannelNumber(string channel) => channel switch
    {
        "A" => 1,
        "B" => 2,
        "C" => 3,
        "D" => 4,
        "E" => 5,
        _ => 1
    };

    private async Task SetChannelIntensity(string channel, int intensity)
    {
        try
        {
            if (!InterfaceService.IsConnected)
            {
                Debug.WriteLine("Interface service not connected, attempting to initialize...");
                await InterfaceService.InitializeAsync();
                await InterfaceService.RegisterDeviceAsync(_selectedDevice);
            }

            if (InterfaceService.IsConnected && !InterfaceService.IsSessionOpen)
            {
                await InterfaceService.OpenSessionAsync();
            }

            // Update local state first
            _channelIntensities[channel] = intensity;

            // Get channel number for SDK
            var channelNumber = GetChannelNumber(channel);

            if (intensity > 0)
            {
                await InterfaceService.ToggleChannelsAsync(channelNumber);
                _activeChannels.Add(channel);
                Debug.WriteLine($"Channel {channel} intensity set to {intensity}");
            }
            else
            {
                // Remove from active channels and turn off
                _activeChannels.Remove(channel);
                await InterfaceService.TurnOffAsync(); // Turn off all channels
                Debug.WriteLine($"Channel {channel} turned off");
            }

            _lastUpdate = DateTime.Now;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to set channel {channel}: {ex.Message}");
            Snackbar.Add($"Failed to control channel {channel}", Severity.Warning);
        }
    }

    private int GetChannelIntensity(string channel) => _channelIntensities.GetValueOrDefault(channel, 0);

    private string GetChannelColor(string channel)
    {
        var intensity = GetChannelIntensity(channel);
        if (intensity == 0) return InactiveGlyphColor;

        var alpha = Math.Max(0.3, intensity / 255.0);
        return $"rgba(0, 255, 136, {alpha:F2})";
    }

    private string GetChannelStyle(string channel) => channel switch
    {
        "A" => "position: absolute; top: 15%; left: 45%; width: 10%; height: 8%;",
        "B" => "position: absolute; top: 25%; right: 15%; width: 12%; height: 6%;",
        "C" => "position: absolute; bottom: 30%; left: 20%; width: 60%; height: 8%;",
        "D" => "position: absolute; bottom: 40%; right: 15%; width: 12%; height: 8%;",
        "E" => "position: absolute; bottom: 15%; left: 45%; width: 10%; height: 6%;",
        _ => "position: absolute; top: 50%; left: 50%; width: 5%; height: 5%;"
    };

    private int[] GetChannelNumbers(string channel) => _selectedDevice switch
    {
        GlyphDeviceType.Phone1 => channel switch
        {
            "A" => GlyphChannels.Phone1.A,
            "B" => GlyphChannels.Phone1.B,
            "C" => GlyphChannels.Phone1.C,
            "D" => GlyphChannels.Phone1.D,
            _ => []
        },
        GlyphDeviceType.Phone2 => channel switch
        {
            "A" => GlyphChannels.Phone2.A,
            "B" => GlyphChannels.Phone2.B,
            "C" => GlyphChannels.Phone2.C,
            "D" => GlyphChannels.Phone2.D,
            "E" => GlyphChannels.Phone2.E,
            _ => []
        },
        GlyphDeviceType.Phone2a => channel switch
        {
            "A" => GlyphChannels.Phone2a.A,
            "B" => GlyphChannels.Phone2a.B,
            "C" => GlyphChannels.Phone2a.C,
            _ => []
        },
        GlyphDeviceType.Phone2aPlus => channel switch
        {
            "A" => GlyphChannels.Phone2aPlus.A,
            "B" => GlyphChannels.Phone2aPlus.B,
            "C" => GlyphChannels.Phone2aPlus.C,
            _ => []
        },
        GlyphDeviceType.Phone3 => channel switch
        {
            "A" => GlyphChannels.Phone3.A,
            "B" => GlyphChannels.Phone3.B,
            "C" => GlyphChannels.Phone3.C,
            _ => []
        },
        _ => []
    };

    // Add these enhanced pattern testing methods to your UnifiedGlyphSimulator.razor:

    private async Task TestMatrixPattern(MatrixPattern pattern)
    {
        try
        {
            // ✅ Ensure matrix service is ready
            if (!MatrixService.IsConnected)
            {
                Debug.WriteLine("Matrix service not connected, initializing...");
                await MatrixService.InitializeAsync();
                await MatrixService.RegisterDeviceAsync(_selectedDevice);
            }

            Debug.WriteLine($"Testing matrix pattern: {pattern}");

            // Clear matrix first
            await MatrixService.TurnOffAsync();
            await Task.Delay(200); // Brief pause for visual feedback

            // Draw the pattern
            var success = pattern switch
            {
                MatrixPattern.Cross => await MatrixService.DrawShapeAsync(GlyphShape.Cross, 12, 12, 10),
                MatrixPattern.Circle => await MatrixService.DrawShapeAsync(GlyphShape.Circle, 12, 12, 8),
                MatrixPattern.Square => await MatrixService.DrawShapeAsync(GlyphShape.Square, 8, 8, 8),
                _ => false
            };

            if (success)
            {
                Snackbar.Add($"{pattern} pattern displayed successfully", Severity.Success);
                Debug.WriteLine($"Drew {pattern} pattern successfully");
            }
            else
            {
                Snackbar.Add($"Failed to display {pattern} pattern", Severity.Error);
                Debug.WriteLine($"Failed to draw {pattern} pattern");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Pattern test failed: {ex.Message}");
            Snackbar.Add($"Pattern test failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task TestSinglePixel()
    {
        try
        {
            Debug.WriteLine($"Testing single pixel at ({_matrixX}, {_matrixY}) with intensity {_matrixIntensity}");

            var success = await MatrixService.SetPixelAsync(_matrixX, _matrixY, _matrixIntensity);

            if (success)
            {
                Snackbar.Add($"Pixel ({_matrixX}, {_matrixY}) set successfully", Severity.Success);
            }
            else
            {
                Snackbar.Add("Failed to set pixel", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Pixel test failed: {ex.Message}");
            Snackbar.Add($"Pixel test failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshDisplay()
    {
        Debug.WriteLine("Refreshing display...");
        _lastUpdate = DateTime.Now;
        SyncMatrixPixelsFromService();
        StateHasChanged();
        await Task.CompletedTask;
    }

    private async Task RefreshMatrixDisplay()
    {
        try
        {
            Debug.WriteLine("Refreshing matrix display...");
            SyncMatrixPixelsFromService();
            StateHasChanged();

            // Optional: Force a service state sync by reading current matrix
            var currentMatrix = MatrixService.CurrentMatrix;
            Debug.WriteLine($"Current matrix has {currentMatrix.Count(i => i > 0)} active pixels");

            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to refresh matrix display: {ex.Message}");
        }
    }

    private async Task AnimateAllChannels()
    {
        try
        {
            var channels = GetVisibleChannels();
            foreach (var channel in channels)
            {
                var channelNumbers = GetChannelNumbers(channel);
                await InterfaceService.AnimateChannelsAsync(channelNumbers, 1000, 3);
                _activeChannels.Add(channel);
                _channelIntensities[channel] = 255;
            }

            Snackbar.Add("Animation started for all channels", Severity.Success);
            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Animation failed: {ex.Message}");
            Snackbar.Add("Failed to animate channels", Severity.Error);
        }

        StateHasChanged();
    }

    private async Task TurnOffAllChannels()
    {
        try
        {
            await InterfaceService.TurnOffAsync();
            _activeChannels.Clear();

            foreach (var channel in _channelIntensities.Keys.ToList())
            {
                _channelIntensities[channel] = 0;
            }

            Debug.WriteLine("All channels turned off");
            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to turn off channels: {ex.Message}");
            Snackbar.Add("Failed to turn off channels", Severity.Warning);
        }

        StateHasChanged();
    }

    // Matrix Management
    private async Task TogglePixel(int x, int y)
    {
        var index = y * IGlyphMatrixService.MatrixWidth + x;
        var currentIntensity = _matrixPixels[index].Intensity;
        var newIntensity = currentIntensity > 0 ? 0 : 255;

        await SetMatrixPixel(x, y, newIntensity);
    }

    private async Task SetMatrixPixel(int x, int y, int intensity)
    {
        var index = y * IGlyphMatrixService.MatrixWidth + x;
        _matrixPixels[index] = new GlyphPixel(x, y, intensity);

        try
        {
            await MatrixService.SetPixelAsync(x, y, intensity);
            Debug.WriteLine($"Matrix pixel ({x}, {y}) set to intensity {intensity}");
            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to set matrix pixel: {ex.Message}");
            Snackbar.Add($"Failed to set pixel ({x}, {y})", Severity.Warning);
        }

        StateHasChanged();
    }

    private async Task SetPixelAtPosition()
    {
        await SetMatrixPixel(_matrixX, _matrixY, _matrixIntensity);
    }

    private async Task ClearMatrixPixels()
    {
        try
        {
            await MatrixService.TurnOffAsync();

            for (int i = 0; i < IGlyphMatrixService.TotalPixels; i++)
            {
                var x = i % IGlyphMatrixService.MatrixWidth;
                var y = i / IGlyphMatrixService.MatrixWidth;
                _matrixPixels[i] = new GlyphPixel(x, y, 0);
            }

            Debug.WriteLine("Matrix cleared");
            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to clear matrix: {ex.Message}");
            Snackbar.Add("Failed to clear matrix", Severity.Warning);
        }

        StateHasChanged();
    }

    private async Task DrawPattern(MatrixPattern pattern)
    {
        var pixels = pattern switch
        {
            MatrixPattern.Cross => GenerateCrossPattern(12, 12, 8),
            MatrixPattern.Circle => GenerateCirclePattern(12, 12, 6),
            MatrixPattern.Square => GenerateSquarePattern(8, 8, 8),
            _ => []
        };

        try
        {
            await MatrixService.SetPixelsAsync(pixels);

            foreach (var pixel in pixels)
            {
                var index = pixel.Y * IGlyphMatrixService.MatrixWidth + pixel.X;
                _matrixPixels[index] = pixel;
            }

            Debug.WriteLine($"Drew {pattern} pattern with {pixels.Count()} pixels");
            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to draw pattern: {ex.Message}");
            Snackbar.Add($"Failed to draw {pattern} pattern", Severity.Warning);
        }

        StateHasChanged();
    }

    private string GetPixelStyle(int x, int y)
    {
        var index = y * IGlyphMatrixService.MatrixWidth + x;
        var intensity = _matrixPixels[index].Intensity;
        var alpha = intensity / 255.0;
        var color = intensity > 0 ? $"rgba(0, 255, 136, {alpha:F2})" : "rgba(64, 64, 64, 0.3)";

        return $"width: calc(100% / 25); height: calc(100% / 25); background-color: {color}; cursor: pointer; transition: all 0.2s ease; border-radius: 1px;";
    }

    // Pattern Generation
    private IEnumerable<GlyphPixel> GenerateCrossPattern(int centerX, int centerY, int size)
    {
        var pixels = new List<GlyphPixel>();
        var halfSize = size / 2;

        // Horizontal line
        for (int x = Math.Max(0, centerX - halfSize); x <= Math.Min(24, centerX + halfSize); x++)
        {
            pixels.Add(new GlyphPixel(x, centerY, 255));
        }

        // Vertical line
        for (int y = Math.Max(0, centerY - halfSize); y <= Math.Min(24, centerY + halfSize); y++)
        {
            pixels.Add(new GlyphPixel(centerX, y, 255));
        }

        return pixels;
    }

    private IEnumerable<GlyphPixel> GenerateCirclePattern(int centerX, int centerY, int radius)
    {
        var pixels = new List<GlyphPixel>();

        for (int x = Math.Max(0, centerX - radius); x <= Math.Min(24, centerX + radius); x++)
        {
            for (int y = Math.Max(0, centerY - radius); y <= Math.Min(24, centerY + radius); y++)
            {
                var distance = Math.Sqrt(Math.Pow(x - centerX, 2) + Math.Pow(y - centerY, 2));
                if (distance <= radius)
                {
                    pixels.Add(new GlyphPixel(x, y, 255));
                }
            }
        }

        return pixels;
    }

    private IEnumerable<GlyphPixel> GenerateSquarePattern(int startX, int startY, int size)
    {
        var pixels = new List<GlyphPixel>();

        for (int x = startX; x < startX + size && x < IGlyphMatrixService.MatrixWidth; x++)
        {
            for (int y = startY; y < startY + size && y < IGlyphMatrixService.MatrixHeight; y++)
            {
                if (x >= 0 && y >= 0)
                {
                    pixels.Add(new GlyphPixel(x, y, 255));
                }
            }
        }

        return pixels;
    }

    // Connection Status
    private string GetConnectionStatus()
    {
        var interfaceConnected = InterfaceService.IsConnected;
        var matrixConnected = MatrixService.IsConnected;

        if (interfaceConnected && matrixConnected) return "Connected";
        if (interfaceConnected || matrixConnected) return "Partial";
        return "Disconnected";
    }

    private Color GetConnectionColor()
    {
        var interfaceConnected = InterfaceService.IsConnected;
        var matrixConnected = MatrixService.IsConnected;

        if (interfaceConnected && matrixConnected) return Color.Success;
        if (interfaceConnected || matrixConnected) return Color.Warning;
        return Color.Error;
    }

    private string GetConnectionIcon()
    {
        var interfaceConnected = InterfaceService.IsConnected;
        var matrixConnected = MatrixService.IsConnected;

        if (interfaceConnected && matrixConnected) return Icons.Material.Filled.Wifi;
        if (interfaceConnected || matrixConnected) return Icons.Material.Filled.SignalWifiStatusbarConnectedNoInternet4;
        return Icons.Material.Filled.WifiOff;
    }

    public void Dispose()
    {
        // Unsubscribe from events
        InterfaceService.ConnectionChanged -= OnInterfaceConnectionChanged;
        MatrixService.ConnectionChanged -= OnMatrixConnectionChanged;
        MatrixService.FrameUpdated -= OnMatrixFrameUpdated;
    }

    private string GetMatrixPixelStyle(int intensity)
    {
        try
        {
            var opacity = Math.Max(0.1, intensity / 255.0); // Minimum visibility
            var color = intensity > 0 ? $"rgba(0, 255, 136, {opacity})" : "rgba(64, 64, 64, 0.3)";

            return $@"
                width: 8px;
                height: 8px;
                background-color: {color};
                border: 1px solid rgba(100, 100, 100, 0.5);
                border-radius: 1px;
                cursor: pointer;
                transition: background-color 0.1s ease;
                flex-shrink: 0;
            ";
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"GetMatrixPixelStyle error: {ex.Message}");
            return "width: 8px; height: 8px; background-color: red; border: 1px solid white;";
        }
    }

    private async Task ToggleMatrixPixel(int x, int y)
    {
        var pixelIndex = y * IGlyphMatrixService.MatrixWidth + x;
        var currentIntensity = _matrixPixels[pixelIndex].Intensity;
        var newIntensity = currentIntensity > 0 ? 0 : 255;

        await MatrixService.SetPixelAsync(x, y, newIntensity);
        Debug.WriteLine($"Matrix pixel ({x}, {y}) toggled to intensity {newIntensity}");
    }

    private void OnMatrixFrameUpdated(object? sender, GlyphMatrixUpdateEventArgs e)
    {
        Debug.WriteLine($"Matrix frame updated: {e.Description}");

        SyncMatrixPixelsFromService();

        _lastUpdate = DateTime.Now;
        InvokeAsync(StateHasChanged);
    }

    private void SyncMatrixPixelsFromService()
    {
        try
        {
            var currentPixels = MatrixService.GetCurrentPixels();

            if (currentPixels == null || currentPixels.Length != IGlyphMatrixService.TotalPixels)
            {
                Debug.WriteLine($"Invalid service pixels array - Expected: {IGlyphMatrixService.TotalPixels}, Got: {currentPixels?.Length ?? 0}");
                return;
            }

            // Ensure our local array is the right size
            if (_matrixPixels.Length != IGlyphMatrixService.TotalPixels)
            {
                Debug.WriteLine("Reinitializing matrix pixels array due to size mismatch");
                InitializeMatrixPixels();
            }

            // Copy pixels safely
            for (int i = 0; i < Math.Min(currentPixels.Length, _matrixPixels.Length); i++)
            {
                _matrixPixels[i] = currentPixels[i].Intensity == 0 ?
                    new GlyphPixel(i % IGlyphMatrixService.MatrixWidth, i / IGlyphMatrixService.MatrixWidth, 0) :
                    currentPixels[i];
            }

            var activePixels = currentPixels.Count(p => p.Intensity > 0);
            Debug.WriteLine($"Matrix pixels synced - Active: {activePixels} / {IGlyphMatrixService.TotalPixels}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error syncing matrix pixels: {ex.Message}");
            // Reinitialize on error
            InitializeMatrixPixels();
        }
    }

    private async Task DumpMatrixState()
    {
        Debug.WriteLine("=== KOWALSKI MATRIX STATE ANALYSIS ===");
        Debug.WriteLine($"Service Connected: {MatrixService.IsConnected}");
        Debug.WriteLine($"Device Registered: {MatrixService.RegisteredDevice}");

        var currentPixels = MatrixService.GetCurrentPixels();
        var activePixels = currentPixels.Count(p => p.Intensity > 0);
        Debug.WriteLine($"Active Pixels: {activePixels} / {IGlyphMatrixService.TotalPixels}");

        // Show first few active pixels
        var activeList = currentPixels.Where(p => p.Intensity > 0).Take(10);
        foreach (var pixel in activeList)
        {
            Debug.WriteLine($"  Active Pixel ({pixel.X}, {pixel.Y}) = {pixel.Intensity}");
        }

        Debug.WriteLine("=== END ANALYSIS ===");
        await Task.CompletedTask;
    }

    private async Task SafeToggleMatrixPixel(int x, int y)
    {
        try
        {
            // Validate coordinates first
            if (x < 0 || x >= IGlyphMatrixService.MatrixWidth ||
                y < 0 || y >= IGlyphMatrixService.MatrixHeight)
            {
                Debug.WriteLine($"Invalid coordinates: ({x}, {y})");
                return;
            }

            var pixelIndex = y * IGlyphMatrixService.MatrixWidth + x;

            // Validate array bounds
            if (pixelIndex < 0 || pixelIndex >= _matrixPixels.Length)
            {
                Debug.WriteLine($"Invalid pixel index: {pixelIndex} (max: {_matrixPixels.Length - 1})");
                return;
            }

            // Ensure pixel is initialized
            if (_matrixPixels[pixelIndex] == null)
            {
                _matrixPixels[pixelIndex] = new GlyphPixel(x, y, 0);
            }

            var currentIntensity = _matrixPixels[pixelIndex].Intensity;
            var newIntensity = currentIntensity > 0 ? 0 : 255;

            // Update local state
            _matrixPixels[pixelIndex] = new GlyphPixel(x, y, newIntensity);

            // Update service
            await MatrixService.SetPixelAsync(x, y, newIntensity);

            Debug.WriteLine($"Matrix pixel ({x}, {y}) toggled to intensity {newIntensity}");
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error in SafeToggleMatrixPixel: {ex.Message}");
            Snackbar.Add($"Failed to toggle pixel ({x}, {y})", Severity.Error);
        }
    }
}